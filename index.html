<div>
    <canvas id="board" width="500" height="500"></canvas>
</div>
<div>
    Enter solution: <input id="moves" width="300"/><br/>
    Enter Game:<br/><textarea id="game" width="3000" height="500"></textarea>
</div>
<button onclick="startgame()">Start</button><br/>
<span id="message"/>
<script>

    // Load the required components
    window.onload=function(){
        canv = document.getElementById("board");
        ctx = canv.getContext("2d");
        started = false;
    }

    // size if the game board. (nxn)
    gameSize = 0;

    // puzzle object
    gameData = {};

    // array of moves
    moves = [];

    // rendering sizes
    tileSize = 0;
    tileSpace = 15;

    // handle to game interval timer
    gameInterval = 0;

    // location of the space
    gapX = 0;
    gapY = 0;


    // Called by the button
    function startgame() {
        try {
            // game data
            gameData = JSON.parse(document.getElementById("game").value);
            gameSize = gameData.puzzle.length;
            tileSize = (canv.width - ((gameSize + 1) * tileSpace)) / gameSize;
            ctx.font = '48px serif';
            console.log("Game size "+gameSize);

            // move data
            moves = JSON.parse(document.getElementById("moves").value);

            renderBoard();
            gameInterval = setInterval(game, 1500);
        } catch (ex) {
            console.log(ex);
        }
    }

    function stopgame(msg) {
        if (msg) {
            console.error(msg)
        }
        window.clearInterval(gameInterval)
    }

    function renderBoard() {
        // black out the board
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canv.width, canv.height);

        // Render
        xPos = yPos = tileSpace;
        for (x = 0; x < gameSize; x++){
            for (y = 0; y < gameSize; y++) {
                
                // render and find the gap
                if (gameData.puzzle[y][x] != -1) {
                    ctx.fillStyle = "lime";
                    ctx.fillRect(xPos, yPos, tileSize, tileSize);
                    ctx.fillStyle = "black"
                    ctx.fillText(gameData.puzzle[y][x], xPos + 48, yPos + 48);
                } else {
                    gapX = x;
                    gapY = y;
                }

                yPos += tileSize + tileSpace;
            }
            yPos = tileSpace;
            xPos += tileSize + tileSpace;
        }
    }

    // check for a sucess state
    function checkGame() {
        expected = 1;
        for (x = 0; x < gameSize; x++){
            for (y = 0; y < gameSize; y++) {
                if (gameData.puzzle[y][x] == -1) {
                    continue;
                }
                if (gameData.puzzle[y][x] != expected) {
                    gameFailed();
                    stopgame("Puzzle not complete");
                    return;
                }
                expected++;
            }
        }
        stopgame("You did it!");
    }

    // Run the game
    function game() {

        // Perform the move
        if (moves.length == 0) {
            checkGame();
            return;
        }
        move = moves[0];
        moves = moves.slice(1);

        switch (move) {
            case "u":
            case "U":
                if (gapY == gameSize - 1) {
                    stopgame("Cannot shift up on bottom edge");
                    break;
                }
                gameData.puzzle[gapY][gapX] = gameData.puzzle[gapY + 1][gapX];
                gameData.puzzle[gapY + 1][gapX] = -1;
                break;
            case "d":
            case "D":
                if (gapY == 0) {
                    stopgame("Cannot shift down on top edge");
                    break;
                }
                gameData.puzzle[gapY][gapX] = gameData.puzzle[gapY - 1][gapX];
                gameData.puzzle[gapY - 1][gapX] = -1;
                break;
            case "l":
            case "L":
                if (gapX == gameSize - 1) {
                    stopgame("Cannot left on right edge");
                    break;
                }
                gameData.puzzle[gapY][gapX] = gameData.puzzle[gapY][gapX + 1];
                gameData.puzzle[gapY][gapX + 1] = -1;
                break;
            case "r":
            case "R":
                if (gapX == 0) {
                    stopgame("Cannot right on left edge");
                    break;
                }
                gameData.puzzle[gapY][gapX] = gameData.puzzle[gapY][gapX - 1];
                gameData.puzzle[gapY][gapX - 1] = -1;
                break;
        }

        renderBoard();

    }

    
</script>