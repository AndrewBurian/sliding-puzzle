<div>
    <canvas id="board" width="500" height="500"></canvas>
</div>
<div>
    Enter solution: <input id="moves" size="80" placeholder="[&quot;U&quot;,&quot;D&quot;,&quot;L&quot;,&quot;R&quot;...]"/><br/>
    Enter Game:<br/><textarea id="game" rows="10" cols="80"></textarea>
</div>
<button onclick="startgame()">Start</button><br/>
<span id="message"/>
<script>

    // Load the required components
    window.onload=function(){
        canv = document.getElementById("board");
        ctx = canv.getContext("2d");
        started = false;
    }

    // frames it takes to move a tile (at ~60fps)
    frameRate = 30;

    // size if the game board. (nxn)
    gameSize = 0;

    // puzzle object
    gameData = {};

    // array of moves
    moves = [];

    // rendering sizes
    tileSize = 0;
    tileSpace = 15;

    // rendering colors
    active = "cyan";
    win = "lime";
    lose = "red";

    // handle to game interval timer
    gameInterval = 0;

    // location of the space
    gapX = 0;
    gapY = 0;

    // current move in progress
    move = "x";
    progress = 0.0;
    movX = 0;
    movY = 0;



    // Called by the button
    function startgame() {
        try {
            // game data
            gameData = JSON.parse(document.getElementById("game").value);
            gameSize = gameData.puzzle.length;
            tileSize = (canv.width - ((gameSize + 1) * tileSpace)) / gameSize;
            ctx.font = tileSize+'px serif';
            console.log("Game size "+gameSize);

            // move data
            moves = JSON.parse(document.getElementById("moves").value);

            renderBoard(active);
            time = 300 + (1000 / moves.length)
            game();
        } catch (ex) {
            console.log(ex);
        }
    }

    function renderBoard(color) {
        // black out the board
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canv.width, canv.height);

        // Render
        xPos = yPos = tileSpace;
        for (x = 0; x < gameSize; x++){
            for (y = 0; y < gameSize; y++) {
                
                // render and find the gap
                if (gameData.puzzle[y][x] != -1) {
                    ctx.fillStyle = color;
                    ctx.fillRect(xPos, yPos, tileSize, tileSize);
                    ctx.fillStyle = "black"
                    ctx.fillText(gameData.puzzle[y][x], xPos, yPos + tileSize);
                } else {
                    gapX = x;
                    gapY = y;
                }

                yPos += tileSize + tileSpace;
            }
            yPos = tileSpace;
            xPos += tileSize + tileSpace;
        }
    }

    function winGame() {
        renderBoard(win);
        window.clearInterval(gameInterval);
    }

    function loseGame() {
        renderBoard(lose);
        window.clearInterval(gameInterval);
    }

    // check for a sucess state
    function checkGame() {
        expected = 1;
        for (y = 0; y < gameSize; y++){
            for (x = 0; x < gameSize; x++) {
                if (gameData.puzzle[y][x] == -1) {
                    continue;
                }
                if (gameData.puzzle[y][x] != expected) {
                    console.log("Expected ("+x+","+y+") to be "+expected+"\nGot: "+ gameData.puzzle[y][x])
                    loseGame();
                    return;
                }
                expected++;
            }
        }
        winGame();
    }

    // Run the game
    function game() {

        // Perform the move
        if (moves.length == 0) {
            checkGame();
            return;
        }
        move = moves[0].toUpperCase();
        moves = moves.slice(1);

        switch (move) {
            case "U":
                if (gapY == gameSize - 1) {
                    loseGame();
                    return;
                }
                movX = gapX;
                movY = gapY + 1;
                break;
            case "D":
                if (gapY == 0) {
                    loseGame();
                    return;
                }
                movX = gapX;
                movY = gapY - 1;
                break;
            case "L":
                if (gapX == gameSize - 1) {
                    loseGame();
                    return;
                }
                movX = gapX + 1;
                movY = gapY;
                break;
            case "R":
                if (gapX == 0) {
                    loseGame();
                    return;
                }
                movX = gapX - 1;
                movY = gapY;
                break;
        }

        progress = 0.0;
        window.requestAnimationFrame(animationFrame);
        renderBoard(active);

    }

    function animationFrame() {
        // full render
        renderBoard(active)

        // calulate tile position
        xPos = movX * (tileSize + tileSpace) + tileSpace
        yPos = movY * (tileSize + tileSpace) + tileSpace

        // blank out the tile that's being moved
        ctx.fillStyle = "black";
        ctx.fillRect(xPos, yPos, tileSize, tileSize);

        advance = 0.3 * Math.cbrt(9.4 * (progress - 0.5)) + 0.5;

        // fill it in a little bit towards the target
        switch(move){
            case "U":
                yPos -= (tileSize + tileSpace) * advance;
                break;
            case "D":
                yPos += (tileSize + tileSpace) * advance;
                break;
            case "L":
                xPos -= (tileSize + tileSpace) * advance;
                break;
            case "R":
                xPos += (tileSize + tileSpace) * advance;
                break;
        }
        ctx.fillStyle = active;
        ctx.fillRect(xPos, yPos, tileSize, tileSize);
        ctx.fillStyle = "black"
        ctx.fillText(gameData.puzzle[movY][movX], xPos, yPos + tileSize);

        // update our progress towards the target
        progress += (1/frameRate);
        if (progress < 1) {
            window.requestAnimationFrame(animationFrame);
            return
        }

        // reassignment
        gameData.puzzle[gapY][gapX] = gameData.puzzle[movY][movX];
        gameData.puzzle[movY][movX] = -1;
        gapX = movX;
        gapY = movY;
        
        // continue the game
        game();
    }

    
</script>